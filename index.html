<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Benchmark dataset generator</title>
  <style>
    .float, .absolute, .flex {
      width: 800px;
      height: 600px;
    }
    .float > div, .absolute > div, .flex > div {
      width: 10px;
      height: 10px;
    }
    .absolute {
      position: relative;
    }
    .absolute > div {
      position: absolute;
    }
    .flex {
      display: flex;
      flex-wrap: wrap;
    }
    .float > div {
      float: left;
    }
  </style>
</head>
<body>
   <h1>Benchmark test</h1>
   <h2>Rendering <span id="num_squares"></span> squares</h2>
   <div id="rendering"></div>
   <form id="benchmark">
      <p>
         <label for="method">Method:</label>
         <select id="method">
           <option value="SVG">Scalable Vector Graphics (SVG)</option>
           <option value="HTML_absolute">HTML DIVs, position: absolute;</option>
           <option value="HTML_flex">HTML DIVs, position: flex;</option>
           <option value="HTML_float">HTML DIVs, float: left;</option>
           <option value="Canvas">Canvas</option>
           <option value="Map_Only">Generating Map only (no rendering)</option>
         </select>
      </p>
 <p>
    <label for="synchronous">Loop mode:</label>
    <select id="synchronous">
      <option value="0">Asynchronous loop</option>
      <option value="1">Synchronous loop</option>
    </select>
 </p>
 <p>
    <label for="cycles">Number of cycles:</label>
    <select id="cycles">
      <option value="1">1</option>
      <option value="10">10</option>
      <option value="20">20</option>
      <option value="50">50</option>
      <option value="100">100</option>
    </select>
 </p>
 <p>
    <input type="submit" value="Run now!">
     <h3>Running time: <span id="runtime" class="waiting-text">...</span> ms</h3>
   </form>
</p>
   <form id="full_benchmark">
     <h4>Full benchmark</h4>
     <p>Comparing all possibilities, 20 cycles (takes a while to compute!)</p>
     <p><input type="submit" value="Run full benchmark"></p>
     <table border="1" cellpadding="4" cellspacing="0">
       <thead>
         <tr>
           <th></th>
           <th>SVG elements</th>
           <th>HTML (position: absolute)</th>
           <th>HTML (position: flex)</th>
           <th>HTML (float: left)</th>
           <th>Canvas</th>
           <th>Map generation only (no rendering)</th>
         </tr>
       </thead>
       <tbody>
         <tr>
           <th>Synchronous loop</th>
           <td><span class="waiting-text" id="sync_SVG">...</span> ms</td>
           <td><span class="waiting-text" id="sync_HTML_absolute">...</span> ms</td>
           <td><span class="waiting-text" id="sync_HTML_flex">...</span> ms</td>
           <td><span class="waiting-text" id="sync_HTML_float">...</span> ms</td>
           <td><span class="waiting-text" id="sync_Canvas">...</span> ms</td>
           <td><span class="waiting-text" id="sync_Map_Only">...</span> ms</td>
         </tr>
         <tr>
           <th>Asynchronous loop</th>
           <td><span class="waiting-text" id="async_SVG">...</span> ms</td>
           <td><span class="waiting-text" id="async_HTML_absolute">...</span> ms</td>
           <td><span class="waiting-text" id="async_HTML_flex">...</span> ms</td>
           <td><span class="waiting-text" id="async_HTML_float">...</span> ms</td>
           <td><span class="waiting-text" id="async_Canvas">...</span> ms</td>
           <td><span class="waiting-text" id="async_Map_Only">...</span> ms</td>
         </tr>
       </tbody>
     </table>
   </form>
   <h3>CSV Output</h3>
   <textarea id="csvdata" rows="6" style="width:100%"></textarea>
   <script>
     const MAPW = 80, MAPH = 60, CELLW = 10, resdiv = document.getElementById('rendering');
     const SESSION_ID = (0x1000000*Math.random()).toString(16).replace('.','-'),
     CSV_HEADERS = `"session","run","approach","loop_type","cycles","duration","timestamp","useragent"`;
     let run_n = 0;

      function make_random_map() {
        let colours = [];
        ['33', '80', 'cc'].forEach(function(r) {
          ['33', '80', 'cc'].forEach(function(g) {
            ['33', '80', 'cc'].forEach(function(b) {
              colours.push(`#${r}${g}${b}`);
            });
          });
        });
        let ncolours = colours.length;
        return Array(MAPH).fill().map(function() {
          return Array(MAPW).fill().map(function() {
            return colours[Math.floor(ncolours * Math.random())];
          });
        });
      }

      function reset_render() {
        resdiv.innerHTML = '';
      }

      function with_SVG() {
        reset_render();
        let map = make_random_map();
        let svgroot = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svgroot.setAttribute('viewBox', `0 0 ${MAPW*CELLW} ${MAPH*CELLW}`);
        svgroot.setAttribute('width', MAPW*CELLW);
        svgroot.setAttribute('height', MAPH*CELLW);
        map.forEach(function(submap, y) {
           submap.forEach(function(colour, x) {
             let rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
             rect.setAttribute('width', CELLW);
             rect.setAttribute('height', CELLW);
             rect.setAttribute('x', x*CELLW);
             rect.setAttribute('y', y*CELLW);
             rect.setAttribute('fill', colour);
             svgroot.appendChild(rect);
           });
         });
         resdiv.appendChild(svgroot);
      }

      function with_HTML_absolute() {
        reset_render();
        let map = make_random_map();
        let divroot = document.createElement("div");
        divroot.className = 'absolute';
         map.forEach(function(submap, y) {
           submap.forEach(function(colour, x) {
             let div = document.createElement("div");
             div.style.left = `${x*CELLW}px`;
             div.style.top = `${y*CELLW}px`;
             div.style.backgroundColor = colour;
             divroot.appendChild(div);
           });
         });
         resdiv.appendChild(divroot);
      }

      function with_HTML_flex() {
        reset_render();
        let map = make_random_map();
        let divroot = document.createElement("div");
        divroot.className = 'flex';
         map.forEach(function(submap, y) {
           submap.forEach(function(colour, x) {
             let div = document.createElement("div");
             div.style.backgroundColor = colour;
             divroot.appendChild(div);
           });
         });
         resdiv.appendChild(divroot);
      }

      function with_HTML_float() {
        reset_render();
        let map = make_random_map();
        let divroot = document.createElement("div");
        divroot.className = 'float';
         map.forEach(function(submap, y) {
           submap.forEach(function(colour, x) {
             let div = document.createElement("div");
             div.style.backgroundColor = colour;
             divroot.appendChild(div);
           });
         });
         resdiv.appendChild(divroot);
      }

      function with_Canvas() {
        reset_render();
        let map = make_random_map();
        resdiv.innerHTML = `<canvas width="${MAPW*CELLW}" height="${MAPH*CELLW}"></canvas>`;
        let ctx = resdiv.querySelector('canvas').getContext('2d');
        map.forEach(function(submap, y) {
           submap.forEach(function(colour, x) {
             ctx.fillStyle = colour;
             ctx.fillRect(x*CELLW, y*CELLW, CELLW, CELLW);
           });
         });
      }

      function with_Map_Only() {
        reset_render();
        make_random_map();
      }

      function loop(synchronous, fn, cycles, after) {
         let start = Date.now();
         if (synchronous) {
           window.setTimeout( function() {
             /* We still defer the launch so the behaviour of other functions doesn't break */
             for (let i = 0; i < cycles; i++) {
               fn();
             }
             let duration = Date.now() - start;
             write_csv_line(fn.name.replace('with_',''), "sync", cycles, duration);
             after(duration);
           } ,0);
         } else {
           let i = 0;
           let loopfn = function() {
            if (i < cycles) {
               i++;
               fn();
               window.setTimeout(loopfn,0);
            } else {
               let duration = Date.now() - start;
               write_csv_line(fn.name.replace('with_',''), "async", cycles, duration);
               after(duration);
            }
           }
           loopfn();
         }
      }

      function reset_csv() {
         document.getElementById('csvdata').textContent = CSV_HEADERS;
      }

      function write_csv_line(approach, loop_type, cycles, duration) {
         document.getElementById('csvdata').textContent +=
         `\n"${SESSION_ID}","${run_n}","${approach}","${loop_type}","${cycles}","${duration}","${new Date().toISOString()}","${navigator.userAgent}"`;
      }

      function beforeBenchmark() {
        run_n++;
        Array.from(document.querySelectorAll("input[type=submit]")).forEach(function(el) {
          el.setAttribute('disabled',1);
        });
        Array.from(document.querySelectorAll(".waiting-text")).forEach(function(el) {
          el.textContent = '...';
        });
      }

      function afterBenchmark() {
          Array.from(document.querySelectorAll("input[type=submit]")).forEach(function(el) {
            el.removeAttribute('disabled');
          });
      }

      function runBenchmark() {
        beforeBenchmark();
        let fn = eval(`with_${document.getElementById('method').value}`);
        let sync = !!+document.getElementById('synchronous').value,
            cycles = parseInt(document.getElementById('cycles').value);
        loop(sync, fn, cycles, function(duration) {
          document.getElementById('runtime').textContent = duration;
          afterBenchmark();
        });
        
      }

      function runFullBenchmark() {
        beforeBenchmark();
        let numCycles = 20, fns = [
          with_Map_Only, with_Canvas, with_HTML_flex, with_HTML_float, with_HTML_absolute, with_SVG
        ], i = 0, totalRun = 0;
        let loopfn = function() {
          if (i<(fns.length*2)) {
            let fn = fns[Math.floor(i/2)], sync = !!(i%2);
            i++;
            loop(sync, fn, numCycles, function(duration) {
              document.getElementById(fn.name.replace('with_',sync? 'sync_' : 'async_')).textContent = (duration);
              totalRun += duration;
              loopfn();
            });
          } else {
            document.getElementById('runtime').textContent = totalRun;
            afterBenchmark();
          }
        }
        loopfn();
      }

      document.getElementById('benchmark').addEventListener('submit', function(evt) {
        evt.preventDefault();
        runBenchmark();
      });

      document.getElementById('full_benchmark').addEventListener('submit', function(evt) {
        evt.preventDefault();
        runFullBenchmark();
      });

      document.getElementById('num_squares').textContent = MAPW * MAPH;
      resdiv.style.width = `${MAPW*CELLW}px`;
      resdiv.style.height = `${MAPH*CELLW}px`;
      reset_csv();
      with_Canvas();

   </script>
</body>
</html>