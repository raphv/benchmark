<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Benchmark dataset generator</title>
  <style></style>
</head>
<body>
   <h1>Benchmark test</h1>
   <h2>Rendering <span id="num_squares"></span> squares</h2>
   <div id="rendering"></div>
   <form id="benchmark">
      <p>
         <label for="model">Type of element:</label>
         <select id="model">
           <option value="SVG">Scalable Vector Graphics</option>
           <option value="HTML">HTML DIVs</option>
           <option value="Canvas">Canvas</option>
         </select>
      </p>
      <p>
    <label for="method">Method (not for Canvas):</label>
    <select id="method">
      <option value="DOM">DOM Manipulation</option>
      <option value="Markup">Writing up markup</option>
    </select>
 </p>
 <p>
    <label for="synchronous">Loop mode:</label>
    <select id="synchronous">
      <option value="0">Asynchronous loop</option>
      <option value="1">Synchronous loop</option>
    </select>
 </p>
 <p>
    <label for="cycles">Number of cycles:</label>
    <select id="cycles">
      <option value="1">1</option>
      <option value="10">10</option>
      <option value="20">20</option>
      <option value="50">50</option>
      <option value="100">100</option>
    </select>
 </p>
 <p>
    <input type="submit" value="Run now!">
     <h3>Running time: <span id="runtime" class="waiting-text">...</span> ms</h3>
   </form>
</p>
   <form id="full_benchmark">
     <h4>Full benchmark</h4>
     <p>Comparing all 10 possibilities, 20 cycles (takes a while to compute!)</p>
     <p><input type="submit" value="Run full benchmark"></p>
     <table border="1" cellpadding="4" cellspacing="0">
       <thead>
         <tr>
           <th rowspan="2"></th>
           <th colspan="2">SVG elements</th>
           <th colspan="2">HTML DIVs</th>
           <th colspan="2">Canvas</th>
         </tr>
         <tr>
           <th>Async. Loop</th>
           <th>Sync. Loop</th>
           <th>Async. Loop</th>
           <th>Sync. Loop</th>
           <th>Async. Loop</th>
           <th>Sync. Loop</th>
         </tr>
       </thead>
       <tbody>
         <tr>
           <th>Manipulating DOM</th>
           <td><span class="waiting-text" id="async_SVG_DOM">...</span> ms</td>
           <td><span class="waiting-text" id="sync_SVG_DOM">...</span> ms</td>
           <td><span class="waiting-text" id="async_HTML_DOM">...</span> ms</td>
           <td><span class="waiting-text" id="sync_HTML_DOM">...</span> ms</td>
           <td rowspan="2"><span class="waiting-text" id="async_Canvas">...</span> ms</td>
           <td rowspan="2"><span class="waiting-text" id="sync_Canvas">...</span> ms</td>
         </tr>
         <tr>
           <th>Writing the markup</th>
           <td><span class="waiting-text" id="async_SVG_Markup">...</span> ms</td>
           <td><span class="waiting-text" id="sync_SVG_Markup">...</span> ms</td>
           <td><span class="waiting-text" id="async_HTML_Markup">...</span> ms</td>
           <td><span class="waiting-text" id="sync_HTML_Markup">...</span> ms</td>
         </tr>
       </tbody>
     </table>
   </form>
   <h3>CSV Output</h3>
   <textarea id="csvdata" rows="6" style="width:100%"></textarea>
   <script>
     const MAPW = 80, MAPH = 60, CELLW = 10, resdiv = document.getElementById('rendering');
     const SESSION_ID = (0x1000000*Math.random()).toString(16),
     CSV_HEADERS = `"session","run","approach","synchronous","cycles","duration","timestamp","useragent"`;
     let run_n = 0;

      function make_random_map() {
        let colours = [];
        ['33', '80', 'cc'].forEach(function(r) {
          ['33', '80', 'cc'].forEach(function(g) {
            ['33', '80', 'cc'].forEach(function(b) {
              colours.push(`#${r}${g}${b}`);
            });
          });
        });
        let ncolours = colours.length;
        return Array(MAPH).fill().map(function() {
          return Array(MAPW).fill().map(function() {
            return colours[Math.floor(ncolours * Math.random())];
          });
        });
      }

      function reset_render() {
        resdiv.innerHTML = '';
      }

      function with_SVG_DOM() {
        reset_render();
        let map = make_random_map();
        let svgroot = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svgroot.setAttribute('viewBox', `0 0 ${MAPW*CELLW} ${MAPH*CELLW}`);
        svgroot.setAttribute('width', MAPW*CELLW);
        svgroot.setAttribute('height', MAPH*CELLW);
         map.forEach(function(submap, y) {
           submap.forEach(function(colour, x) {
             let rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
             rect.setAttribute('width', CELLW);
             rect.setAttribute('height', CELLW);
             rect.setAttribute('x', x*CELLW);
             rect.setAttribute('y', y*CELLW);
             rect.setAttribute('fill', colour);
             svgroot.appendChild(rect);
           });
         });
         resdiv.appendChild(svgroot);
      }

      function with_SVG_Markup() {
        reset_render();
        let map = make_random_map();
        let res = `<svg viewBox="0 0 ${MAPW*CELLW} ${MAPH*CELLW}" width="${MAPW*CELLW}" height="${MAPH*CELLW}">` + map.map(function(submap, y) {
             return submap.map(function(colour, x) {
               return `<rect width="${CELLW}" height="${CELLW}" x="${x*CELLW}" y="${y*CELLW}" fill="${colour}" />`;
             }).join('')
           }).join('') + '</svg>';
        resdiv.innerHTML = res;
      }

      function with_HTML_DOM() {
        reset_render();
        let map = make_random_map();
        let divroot = document.createElement("div");
        divroot.style.width = `${MAPW*CELLW}px`;
        divroot.style.height = `${MAPH*CELLW}px`;
        divroot.style.position = `relative`;
         map.forEach(function(submap, y) {
           submap.forEach(function(colour, x) {
             let div = document.createElement("div");
             div.style.position = 'absolute';
             div.style.width = `${CELLW}px`;
             div.style.height = `${CELLW}px`;
             div.style.left = `${x*CELLW}px`;
             div.style.top = `${y*CELLW}px`;
             div.style.backgroundColor = colour;
             divroot.appendChild(div);
           });
         });
         resdiv.appendChild(divroot);
      }

      function with_HTML_Markup() {
        reset_render();
        let map = make_random_map();
        let res = `<div style="width: ${MAPW*CELLW}px; height: ${MAPH*CELLW}px; position: relative;">` + map.map(function(submap, y) {
             return submap.map(function(colour, x) {
               return `<div style="position: absolute; width: ${CELLW}px; height:${CELLW}px; left:${x*CELLW}px; top:${y*CELLW}px; background-color: ${colour};"></div>`;
             }).join('')
           }).join('') + '</div>';
        resdiv.innerHTML = res;
      }


      function with_Canvas() {
        reset_render();
        let map = make_random_map();
        resdiv.innerHTML = `<canvas width="${MAPW*CELLW}" height="${MAPH*CELLW}"></canvas>`;
        let ctx = resdiv.querySelector('canvas').getContext('2d');
        map.forEach(function(submap, y) {
           submap.forEach(function(colour, x) {
             ctx.fillStyle = colour;
             ctx.fillRect(x*CELLW, y*CELLW, CELLW, CELLW);
           });
         });
      }

      function loop(synchronous, fn, cycles, after) {
         let start = Date.now();
         if (synchronous) {
           window.setTimeout( function() {
             /* We still defer the launch so the behaviour of other functions doesn't break */
             for (let i = 0; i < cycles; i++) {
               fn();
             }
             let duration = Date.now() - start;
             write_csv_line(fn.name.replace('with_',''), true, cycles, duration);
             after(duration);
           } ,0);
         } else {
           let i = 0;
           let loopfn = function() {
            if (i < cycles) {
               i++;
               fn();
               window.setTimeout(loopfn,0);
            } else {
               let duration = Date.now() - start;
               write_csv_line(fn.name.replace('with_',''), false, cycles, duration);
               after(duration);
            }
           }
           loopfn();
         }
      }

      function reset_csv() {
         document.getElementById('csvdata').textContent = CSV_HEADERS;
      }

      function write_csv_line(approach, synchronous, cycles, duration) {
         document.getElementById('csvdata').textContent +=
         `\n"${SESSION_ID}","${run_n}","${approach}","${synchronous}","${cycles}","${duration}","${new Date().toISOString()}","${navigator.userAgent}"`;
      }

      function beforeBenchmark() {
        run_n++;
        Array.from(document.querySelectorAll("input[type=submit]")).forEach(function(el) {
          el.setAttribute('disabled',1);
        });
        Array.from(document.querySelectorAll(".waiting-text")).forEach(function(el) {
          el.textContent = '...';
        });
      }

      function afterBenchmark() {
          Array.from(document.querySelectorAll("input[type=submit]")).forEach(function(el) {
            el.removeAttribute('disabled');
          });
      }

      function runBenchmark() {
        beforeBenchmark();
        let method = document.getElementById('method').value,
          model = document.getElementById('model').value,
          fn;
        if (model === 'Canvas') {
          fn = with_Canvas;
        } else {
            if (model === 'HTML') {
              if (method === 'DOM') {
                fn = with_HTML_DOM;
              } else {
                fn = with_HTML_Markup;
              }
            } else {
              if (method === 'DOM') {
                fn = with_SVG_DOM;
              } else {
                fn = with_SVG_Markup;
              }
            }
        }
        let sync = !!+document.getElementById('synchronous').value,
            cycles = parseInt(document.getElementById('cycles').value);
        loop(sync, fn, cycles, function(duration) {
          document.getElementById('runtime').textContent = duration;
          afterBenchmark();
        });
        
      }

      function runFullBenchmark() {
        beforeBenchmark();
        let numCycles = 20, fns = [
          with_Canvas, with_HTML_DOM, with_HTML_Markup, with_SVG_DOM, with_SVG_Markup
        ], i = 0, totalRun = 0;
        let loopfn = function() {
          if (i<(fns.length*2)) {
            let fn = fns[Math.floor(i/2)], sync = !!(i%2);
            i++;
            loop(sync, fn, numCycles, function(duration) {
              document.getElementById(fn.name.replace('with_',sync? 'sync_' : 'async_')).textContent = (duration);
              totalRun += duration;
              loopfn();
            });
          } else {
            document.getElementById('runtime').textContent = totalRun;
            afterBenchmark();
          }
        }
        loopfn();
      }

      document.getElementById('model').addEventListener('change', function(evt) {
        if (evt.target.value === 'Canvas') {
           document.getElementById('method').setAttribute('disabled', 1);
        } else {
          document.getElementById('method').removeAttribute('disabled');
        }
      });

      document.getElementById('benchmark').addEventListener('submit', function(evt) {
        evt.preventDefault();
        runBenchmark();
      });

      document.getElementById('full_benchmark').addEventListener('submit', function(evt) {
        evt.preventDefault();
        runFullBenchmark();
      });

      document.getElementById('num_squares').textContent = MAPW * MAPH;

      reset_csv();
      with_Canvas();

   </script>
</body>
</html>