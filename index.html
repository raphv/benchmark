<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Benchmark dataset generator</title>
  <style>
    .float, .absolute, .flex {
      width: 800px;
      height: 600px;
    }
    .float > div, .absolute > div, .flex > div {
      width: 10px;
      height: 10px;
    }
    .absolute {
      position: relative;
    }
    .absolute > div {
      position: absolute;
    }
    .flex {
      display: flex;
      flex-wrap: wrap;
    }
    .float > div {
      float: left;
    }
  </style>
</head>
<body>
   <h1>Benchmark test</h1>
   <h2>Rendering <span id="num_squares"></span> squares</h2>
   <div id="rendering"></div>
   <form id="benchmark">
      <p>
         <label for="method">Method:</label>
         <select id="method">
           <option value="SVG">Scalable Vector Graphics (SVG)</option>
           <option value="HTML_absolute">HTML DIVs, position: absolute;</option>
           <option value="HTML_flex">HTML DIVs, position: flex;</option>
           <option value="HTML_float">HTML DIVs, float: left;</option>
           <option value="Canvas">Canvas</option>
           <option value="Map_Only">Generating Map only (no rendering)</option>
         </select>
      </p>
 <p>
    <label for="synchronous">Loop mode:</label>
    <select id="synchronous">
      <option value="0">Asynchronous loop</option>
      <option value="1">Synchronous loop</option>
    </select>
 </p>
 <p>
    <label for="cycles">Number of cycles:</label>
    <select id="cycles">
      <option value="1">1</option>
      <option value="10">10</option>
      <option value="20">20</option>
      <option value="50">50</option>
      <option value="60">60</option>
      <option value="100">100</option>
    </select>
 </p>
 <p>
    <input type="submit" value="Run now!">
     <h3>Running time: <span id="runtime" class="waiting-text">...</span> ms</h3>
   </form>
</p>
   <form id="full_benchmark">
     <h4>Full benchmark</h4>
     <p>Comparing all possibilities, 50 cycles (takes a while to compute!)</p>
     <p><input type="submit" value="Run full benchmark"></p>
     <table border="1" cellpadding="4" cellspacing="0">
       <thead>
         <tr>
           <th></th>
           <th>SVG elements</th>
           <th>HTML (position: absolute)</th>
           <th>HTML (position: flex)</th>
           <th>HTML (float: left)</th>
           <th>Canvas</th>
           <th>Map generation only (no rendering)</th>
         </tr>
       </thead>
       <tbody>
         <tr>
           <th>Synchronous loop</th>
           <td><span class="waiting-text" id="sync_SVG">...</span> ms</td>
           <td><span class="waiting-text" id="sync_HTML_absolute">...</span> ms</td>
           <td><span class="waiting-text" id="sync_HTML_flex">...</span> ms</td>
           <td><span class="waiting-text" id="sync_HTML_float">...</span> ms</td>
           <td><span class="waiting-text" id="sync_Canvas">...</span> ms</td>
           <td><span class="waiting-text" id="sync_Map_Only">...</span> ms</td>
         </tr>
         <tr>
           <th>Asynchronous loop</th>
           <td><span class="waiting-text" id="async_SVG">...</span> ms</td>
           <td><span class="waiting-text" id="async_HTML_absolute">...</span> ms</td>
           <td><span class="waiting-text" id="async_HTML_flex">...</span> ms</td>
           <td><span class="waiting-text" id="async_HTML_float">...</span> ms</td>
           <td><span class="waiting-text" id="async_Canvas">...</span> ms</td>
           <td><span class="waiting-text" id="async_Map_Only">...</span> ms</td>
         </tr>
       </tbody>
     </table>
   </form>
   <h3>CSV Output</h3>
   <textarea id="csvdata" rows="6" style="width:100%"></textarea>
   <script>
      const MAPW = 80, MAPH = 60, CELLW = 10, resdiv = document.getElementById('rendering');
      const SESSION_ID = Math.floor(0x1000000*Math.random()).toString(16),
      CSV_HEADERS = `"session","run","approach","loop_type","cycles","duration","timestamp","os","browser","useragent"`;
      let run_id = null;

      let browserName = "other";

      if (navigator.userAgent.indexOf('Chrome/') !== -1) {
        browserName = "Chrome"; // Can also be Edge, but this is tested later
      }
      if (navigator.userAgent.indexOf('Safari/') !== -1) {
        browserName = "Safari"; // Can also be Edge, but this is tested later
      }
      if (navigator.userAgent.indexOf('Edg/') !== -1) {
        browserName = "Edge";
      }
      if (navigator.userAgent.indexOf('Firefox/') !== -1) {
        browserName = "Firefox";
      }

      let osName = "other";
      if (navigator.userAgent.indexOf('Windows') !== -1) {
        osName = "Windows";
      }
      if (navigator.userAgent.indexOf('Android') !== -1) {
        osName = "Android";
      }
      if (navigator.userAgent.indexOf('Macintosh') !== -1) {
        osName = "MacOS";
      }

      let sysdetailcsv = `"${osName}","${browserName}","${navigator.userAgent}"`;

      function make_random_map(flat) {
        let colours = [];
        ['33', '80', 'cc'].forEach(function(r) {
          ['33', '80', 'cc'].forEach(function(g) {
            ['33', '80', 'cc'].forEach(function(b) {
              colours.push(`#${r}${g}${b}`);
            });
          });
        });
        let ncolours = colours.length;
        if (flat) {
          return Array(MAPW*MAPH).fill().map(function() {
            return colours[Math.floor(ncolours * Math.random())];
          });
        }
        return Array(MAPH).fill().map(function() {
          return Array(MAPW).fill().map(function() {
            return colours[Math.floor(ncolours * Math.random())];
          });
        });
      }

      function reset_render() {
        resdiv.innerHTML = '';
        resdiv.className = '';
      }

      function SVG() {
        let svgroot = null;
        this.name = 'SVG';
        this.setup = function() {
          reset_render();
          svgroot = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          svgroot.setAttribute('viewBox', `0 0 ${MAPW*CELLW} ${MAPH*CELLW}`);
          svgroot.setAttribute('width', MAPW*CELLW);
          svgroot.setAttribute('height', MAPH*CELLW);
          for (let x=0; x<MAPW; x++) {
            for (let y=0; y<MAPH; y++) {
              let rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
              rect.setAttribute('width', CELLW);
              rect.setAttribute('height', CELLW);
              rect.setAttribute('x', x*CELLW);
              rect.setAttribute('y', y*CELLW);
              svgroot.appendChild(rect);
            }
          }
          resdiv.appendChild(svgroot);
        }
        this.run = function() {
          let map = make_random_map(true)
          console.log
          Array.from(svgroot.children).forEach(function(rect, i) {
            rect.setAttribute('fill',map[i]);
          });
        }
      }

      function HTML_absolute() {
        this.name = 'HTML_absolute';
        this.setup = function() {
          reset_render();
          resdiv.className = 'absolute';
          for (let x=0; x<MAPW; x++) {
            for (let y=0; y<MAPH; y++) {
              let div = document.createElement("div");
              div.style.left = `${x*CELLW}px`;
              div.style.top = `${y*CELLW}px`;
              resdiv.appendChild(div);
            }
          }
        }
        this.run = function() {
          let map = make_random_map(true)
          Array.from(resdiv.children).forEach(function(div, i) {
            div.style.backgroundColor = map[i];
          });
        }
      }

      function HTML_flex() {
        this.name = 'HTML_flex';
        this.setup = function() {
          reset_render();
          resdiv.className = 'flex';
          let total = MAPW*MAPH;
          for (let i=0; i<total; i++) {
            let div = document.createElement("div");
            resdiv.appendChild(div);
          }
        }
        this.run = function() {
          let map = make_random_map(true)
          Array.from(resdiv.children).forEach(function(div, i) {
            div.style.backgroundColor = map[i];
          });
        }
      }

      function HTML_float() {
        this.name = 'HTML_float';
        this.setup = function() {
          reset_render();
          resdiv.className = 'float';
          let total = MAPW*MAPH;
          for (let i=0; i<total; i++) {
            let div = document.createElement("div");
            resdiv.appendChild(div);
          }
        }
        this.run = function() {
          let map = make_random_map(true)
          Array.from(resdiv.children).forEach(function(div, i) {
            div.style.backgroundColor = map[i];
          });
        }
      }

      function Canvas() {
        let ctx = null;
        this.name = 'Canvas';
        this.setup = function() {
          reset_render();
          resdiv.innerHTML = `<canvas width="${MAPW*CELLW}" height="${MAPH*CELLW}"></canvas>`;
          ctx = resdiv.querySelector('canvas').getContext('2d');
        }
        this.run = function() {
          make_random_map().forEach(function(submap, y) {
             submap.forEach(function(colour, x) {
               ctx.fillStyle = colour;
               ctx.fillRect(x*CELLW, y*CELLW, CELLW, CELLW);
             });
           });
        }
      }

      function Map_Only() {
        this.name = 'Map_Only';
        this.setup = function() {
          reset_render();
        }
        this.run = function() {
          make_random_map();
        }
        
      }

      function loop(synchronous, methodobj, cycles, after) {
         let start = Date.now();
         if (synchronous) {
           window.setTimeout( function() {
             /* We still defer the launch so the behaviour of other functions doesn't break */
             methodobj.setup();
             for (let i = 0; i < cycles; i++) {
               methodobj.run();
             }
             let duration = Date.now() - start;
             write_csv_line(methodobj.name, "sync", cycles, duration);
             after(duration);
           } ,0);
         } else {
           let i = 0;
           let loopfn = function() {
            if (!i) {
              methodobj.setup();
            }
            if (i < cycles) {
               i++;
               methodobj.run();
               window.setTimeout(loopfn,0);
            } else {
               let duration = Date.now() - start;
               write_csv_line(methodobj.name, "async", cycles, duration);
               after(duration);
            }
           }
           loopfn();
         }
      }

      function reset_csv() {
         document.getElementById('csvdata').textContent = CSV_HEADERS;
      }

      function write_csv_line(approach, loop_type, cycles, duration) {
         document.getElementById('csvdata').textContent +=
         `\n"${SESSION_ID}","${run_id}","${approach}","${loop_type}","${cycles}","${duration}","${new Date().toISOString()}",${sysdetailcsv}`;
      }

      function beforeBenchmark() {
        run_id = Math.floor(0x1000000*Math.random()).toString(16);
        Array.from(document.querySelectorAll("input[type=submit]")).forEach(function(el) {
          el.setAttribute('disabled',1);
        });
        Array.from(document.querySelectorAll(".waiting-text")).forEach(function(el) {
          el.textContent = '...';
        });
      }

      function afterBenchmark() {
          Array.from(document.querySelectorAll("input[type=submit]")).forEach(function(el) {
            el.removeAttribute('disabled');
          });
      }

      function runBenchmark() {
        beforeBenchmark();
        let methodobj = new (eval(`${document.getElementById('method').value}`));
        let sync = !!+document.getElementById('synchronous').value,
            cycles = parseInt(document.getElementById('cycles').value);
        loop(sync, methodobj, cycles, function(duration) {
          document.getElementById('runtime').textContent = duration;
          afterBenchmark();
        });
        
      }

      function runFullBenchmark() {
        beforeBenchmark();
        let numCycles = 50, fns = [
          Map_Only, Canvas, HTML_float, HTML_flex, HTML_absolute, SVG
        ], i = 0, totalRun = 0;
        let loopfn = function() {
          if (i<(fns.length*2)) {
            let fn = fns[Math.floor(i/2)], sync = !!(i%2);
            i++;
            loop(sync, new fn, numCycles, function(duration) {
              document.getElementById((sync? 'sync_' : 'async_') + fn.name).textContent = (duration);
              totalRun += duration;
              loopfn();
            });
          } else {
            document.getElementById('runtime').textContent = totalRun;
            afterBenchmark();
          }
        }
        loopfn();
      }

      document.getElementById('benchmark').addEventListener('submit', function(evt) {
        evt.preventDefault();
        runBenchmark();
      });

      document.getElementById('full_benchmark').addEventListener('submit', function(evt) {
        evt.preventDefault();
        runFullBenchmark();
      });

      document.getElementById('num_squares').textContent = MAPW * MAPH;
      resdiv.style.width = `${MAPW*CELLW}px`;
      resdiv.style.height = `${MAPH*CELLW}px`;
      reset_csv();
      let firstrun = new Canvas();
      firstrun.setup();
      firstrun.run();

   </script>
</body>
</html>